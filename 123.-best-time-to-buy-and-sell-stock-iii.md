# 123. Best Time to Buy and Sell Stock III

{% embed url="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" %}

遍历 prices，对于每个元素（价格）都有三个选择：1.买，2.卖，3.不操作，终止条件也很明确：遍历结束，或买/卖均达到2次。

### Backtracking

树形发展的多个sequence里面找合格/最优，我觉得可以试试 backtracking，但这题直接这样写会 TLE，即便已经用了memo.

### DP

改成 DP 返回当前位置往后可能的 max profit，相当于从终止（0）往前逆增，勉强能过。



{% tabs %}
{% tab title="" %}
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        self.memo = dict()
        
        def maxLocal(idx, buy, sell):
            # ending conditions
            if sell == 2 or idx == len(prices):
                return 0
            if (idx, buy, sell) in self.memo:
                return self.memo[(idx, buy, sell)]
            # keep going
            else:
                hold = maxLocal(idx+1, buy, sell)
                b = maxLocal(idx+1, buy+1, sell) - prices[idx] if (buy < 2 and buy == sell) else float("-inf")
                s = maxLocal(idx+1, buy, sell+1) + prices[idx] if (sell < 2 and buy > sell) else float("-inf")
                self.memo[(idx, buy, sell)] = max([hold, b, s])
                return self.memo[(idx, buy, sell)]
                        
        return maxLocal(0, 0, 0)
```
{% endtab %}

{% tab title="Backtracking \(TLE\)" %}
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        self.maxProfit = 0
        memo = set()
        
        def backtrack(idx, buy, sell, balance):
            # ending conditions
            if sell == 2 or idx == len(prices):
                self.maxProfit = max(self.maxProfit, balance)
                return
            if (idx, buy, sell, balance) in memo:
                return 
            # keep going
            else:
                memo.add((idx, buy, sell, balance))
                # do nothing, just wait for next trade day
                backtrack(idx+1, buy, sell, balance)
                # have chance to buy
                if buy < 2 and buy == sell:
                    backtrack(idx+1, buy+1, sell, balance-prices[idx])
                # have chance to sell
                if sell < 2 and buy > sell:
                    backtrack(idx+1, buy, sell+1, balance+prices[idx])
        
        backtrack(0, 0, 0, 0)
        
        return self.maxProfit
```
{% endtab %}
{% endtabs %}

